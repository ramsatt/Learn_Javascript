<h1>TypeScript Classes</h1>



<hr>

<p>TypeScript adds types and visibility modifiers to JavaScript classes.</p>
<p>Learn more about JavaScript classes <a href="../js/js_classes.html">here</a>.</p>

<hr>

<h2>Members: Types</h2>
<p>The members of a class (properties &amp; methods) are typed using type annotations, similar to variables.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
class Person {<br>
&nbsp;&nbsp;name: string;<br>
}<br>
<br>
const person = new Person();<br>
person.name = "Jane";<br>
</div>


</div>

<hr>

<hr>

<h2>Members: Visibility</h2>
<p>Class members can also be given special modifiers that affect visibility.</p>

<div class="w3-panel ws-info">
<p>There are three main visibility modifiers in TypeScript.</p>

<ul>
<li><code class="w3-codespan">public</code> - (default) allows access to the class member from anywhere</li>
<li><code class="w3-codespan">private</code> - only allows access to the class member from within the class</li>
<li><code class="w3-codespan">protected</code> - allows access to the class member from itself and any classes that inherit it, which is covered in the inheritance section below</li>
</ul>
</div>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
class Person {<br>
&nbsp;&nbsp;private name: string;<br>
<br>
&nbsp;&nbsp;public constructor(name: string) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;public getName(): string {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.name;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
const person = new Person("Jane");<br>
console.log(person.getName()); // person.name isn't accessible from outside the class since it's private<br>
</div>


</div>

<div class="w3-panel ws-info">
The <code class="w3-codespan">this</code> keyword in a class usually refers to the instance of the class.
Read more about <code class="w3-codespan">this</code> <a href="../js/js_this.html">here</a>.
</div>

<hr>

<h2>Parameter Properties</h2>
<p>TypeScript provides a convenient way to define class members in the constructor, by adding a visibility modifier to the parameter.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
class Person {<br>
&nbsp;&nbsp;// name is a private member variable<br>
&nbsp;&nbsp;public constructor(private name: string) {}<br>
<br>
&nbsp;&nbsp;public getName(): string {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.name;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
const person = new Person("Jane");<br>
console.log(person.getName());<br>
</div>


</div>

<hr>

<h2>Readonly</h2>
<p>Similar to arrays, the <code class="w3-codespan">readonly</code> keyword can prevent class members from being changed.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
class Person {<br>
&nbsp;&nbsp;private readonly name: string;<br>
<br>
&nbsp;&nbsp;public constructor(name: string) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// name cannot be changed after this initial definition, which has to be either at its declaration or in the constructor.<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;public getName(): string {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.name;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
const person = new Person("Jane");<br>
console.log(person.getName());
</div>


</div>

<hr>

<h2>Inheritance: Implements</h2>
<p>Interfaces (covered <a href="typescript_aliases_and_interfaces.html">here</a>) can be used to define the type a class must follow through the <code class="w3-codespan">implements</code> keyword.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
interface Shape {<br>
&nbsp;&nbsp;getArea: () =&gt; number;<br>
}<br>
<br>
class Rectangle implements Shape {<br>
&nbsp;&nbsp;public constructor(protected readonly width: number, protected readonly height: number) {}<br>
<br>
&nbsp;&nbsp;public getArea(): number {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.width * this.height;<br>
&nbsp;&nbsp;}<br>
}<br>
</div>


</div>

<div class="w3-panel ws-info">
A class can implement multiple interfaces by listing each one after <code class="w3-codespan">implements</code>, separated by a comma like so: <code class="w3-codespan">class Rectangle implements Shape, Colored {</code>
</div>

<hr>

<h2>Inheritance: Extends</h2>
<p>Classes can extend each other through the <code class="w3-codespan">extends</code> keyword.</p>
<p>A class can only extend one other class.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
interface Shape {<br>
&nbsp;&nbsp;getArea: () =&gt; number;<br>
}<br>
<br>
class Rectangle implements Shape {<br>
&nbsp;&nbsp;public constructor(protected readonly width: number, protected readonly height: number) {}<br>
<br>
&nbsp;&nbsp;public getArea(): number {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.width * this.height;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
class Square extends Rectangle {<br>
&nbsp;&nbsp;public constructor(width: number) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;super(width, width);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// getArea gets inherited from Rectangle<br>
}<br>
</div>


</div>

<hr>

<h2>Override</h2>
<p>When a class extends another class, it can replace the members of the parent class with the same name.</p>
<p>Newer versions of TypeScript allow explicitly marking this with the <code class="w3-codespan">override</code> keyword.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
interface Shape {<br>
&nbsp;&nbsp;getArea: () =&gt; number;<br>
}<br>
<br>
class Rectangle implements Shape {<br>
&nbsp;&nbsp;// using protected for these members allows access from classes that extend from this class, such as Square<br>
&nbsp;&nbsp;public constructor(protected readonly width: number, protected readonly height: number) {}<br>
<br>
&nbsp;&nbsp;public getArea(): number {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.width * this.height;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;public toString(): string {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return `Rectangle[width=${this.width}, height=${this.height}]`;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
class Square extends Rectangle {<br>
&nbsp;&nbsp;public constructor(width: number) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;super(width, width);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;// this toString replaces the toString from Rectangle<br>
&nbsp;&nbsp;public override toString(): string {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return `Square[width=${this.width}]`;<br>
&nbsp;&nbsp;}<br>
}<br>
</div>


</div>

<div class="w3-panel ws-info">
<p>By default the <code class="w3-codespan">override</code> keyword is optional when overriding a method, and only helps to prevent accidentally overriding a method that does not exist.</p>
<p>Use the setting <code class="w3-codespan">noImplicitOverride</code> to force it to be used when overriding.</p>
</div>

<hr>

<h2>Abstract Classes</h2>
<p>Classes can be written in a way that allows them to be used as a base class for other classes without having to implement all the members.</p>
<p>This is done by using the <code class="w3-codespan">abstract</code> keyword.</p>
<p>Members that are left unimplemented also use the <code class="w3-codespan">abstract</code> keyword.</p>

<div class="w3-example">
<h3>Example</h3>

<div class="w3-code notranslate jsHigh">
abstract class Polygon {<br>
&nbsp;&nbsp;public abstract getArea(): number;<br>
<br>
&nbsp;&nbsp;public toString(): string {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return `Polygon[area=${this.getArea()}]`;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
class Rectangle extends Polygon {<br>
&nbsp;&nbsp;public constructor(protected readonly width: number, protected readonly height: number) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;super();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;public getArea(): number {<br>
&nbsp;&nbsp;&nbsp;&nbsp;return this.width * this.height;<br>
&nbsp;&nbsp;}<br>
}<br>
</div>


</div>

<div class="w3-panel ws-info">
Abstract classes cannot be directly instantiated, as they do not have all their members implemented.
</div>

<hr>

<hr>
<br>